#!/usr/bin/env bash

set -e

# info on enlarging a disk image: https://unix.stackexchange.com/questions/217013/enlarge-a-filesystem-image

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

source "${SCRIPT_DIR}/disk-image-utils"

assert_config DISK_IMAGE_PATH
assert_valid_file "${DISK_IMAGE_PATH}"

assert_config SCRIPT
assert_valid_file "${SCRIPT}"

MOUNT_POINT=
if [ ! -z "${FILES_TO_MOUNT}" ]; then
  if [ -z "${MOUNT_PATH}" ]; then
    die "When specifying FILES_TO_MOUNT, you must also specify a MOUNT_PATH."
  fi

  regex='^/.*$'
  if ! [[ "${MOUNT_PATH}" =~ $regex ]]; then
    die "MOUNT_PATH must be an absolute path."
  fi

  MOUNT_POINT_REALPATH=$(realpath --canonicalize-missing --relative-base=image-root "image-root${MOUNT_PATH}")
  # if this path is absolute, it means we moved up out of our intended base directory
  # because this could be an attempt to do something nefarious, we keep the error generic
  if [[ "${MOUNT_POINT_REALPATH}" =~ $regex ]]; then
    die "MOUNT_PATH is invalid."
  fi
  MOUNT_POINT="image-root/${MOUNT_POINT_REALPATH}"
fi

LOSETUP_ARGS=(-f --show)
# add partition offset argument, if we have a valid PARTITION_NUMBER configuration
if [ ! -z "${PARTITION_NUMBER}" ]; then
  regex='^[0-9]+$'
  if ! [[ "${PARTITION_NUMBER}" =~ $regex ]]; then
    die "PARTITION_NUMBER must be a number."
  fi
  if [ ! "${PARTITION_NUMBER}" -gt 0 ]; then
    die "PARTITION_NUMBER must be greater than zero."
  fi

  PARTITION_TYPE=$(get_partition_type "${DISK_IMAGE_PATH}" "${PARTITION_NUMBER}")
  if [ "${PARTITION_TYPE}" != "Linux" ]; then
    echo "Expected 'Linux' partition type, but found: ${PARTITION_TYPE}."
    echo "This is probably not going to work as expected..."
  fi

  LOSETUP_ARGS+=(-o $(get_partition_offset "${DISK_IMAGE_PATH}" "${PARTITION_NUMBER}"))
fi
LOSETUP_ARGS+=("${DISK_IMAGE_PATH}")

mkdir -p image-root
# set -x
LOOP_DEVICE=$(losetup "${LOSETUP_ARGS[@]}")

# we want to make sure we run the `umount` and `losetup -d` commands, even if previous commands fail
# consider: http://redsymbol.net/articles/bash-exit-traps/
set +e

# mount the image and perform the edits
mount "${LOOP_DEVICE}" image-root && \
  ([ ! -z "${FILES_TO_MOUNT}" ] && mkdir -p "${MOUNT_POINT}" && mount --bind "${FILES_TO_MOUNT}" "${MOUNT_POINT}") && \
  cat "${SCRIPT}" | chroot image-root bash -

# clean up devices and mounts
([ ! -z "${FILES_TO_MOUNT}" ] && umount "${MOUNT_POINT}")
umount image-root
losetup -d "${LOOP_DEVICE}"

set -e
# { set +x; } 2>/dev/null