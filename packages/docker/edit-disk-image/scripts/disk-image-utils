#!/usr/bin/env bash

set -e

trap "exit 1" TERM

function die ()
{
  local message="$1"
  echo "${message}"
  kill -s TERM $$
}

function assert_config ()
{
  if [ -z "${!1}" ]; then
    die "You must supply a value for the '${1}' enviroment variable."
  fi
}

# assert_valid_value <VARIABLE_NAME> [OPTION_1] [OPTION_2] ... [OPTION_n]
function assert_valid_value ()
{
  local variable_name="$1"    
  shift              
  local valid_options=("$@")

  assert_config "${variable_name}"

  local value=${!variable_name}
  if [[ ! " ${valid_options[*]} " == *"${!variable_name}"* ]];
  then
    die "Invalid value for ${variable_name} (${value}). Expected one of: ${valid_options}"
  fi
}

function assert_valid_file ()
{
  local file_name="$1"
  if [ ! -f "${file_name}" ]; then
    die "File does not exist: ${file_name}"
  fi
}

# info on enlarging a disk image: https://unix.stackexchange.com/questions/217013/enlarge-a-filesystem-image

# Sample output for the fdisk commands parsed by these utils:
# Disk work/original.img: 1.74 GiB, 1853882368 bytes, 3620864 sectors
# Units: sectors of 1 * 512 = 512 bytes
# Sector size (logical/physical): 512 bytes / 512 bytes
# I/O size (minimum/optimal): 512 bytes / 512 bytes
# Disklabel type: dos
# Disk identifier: 0x2fed7fee
#
#  Start Type
#   8192 W95 FAT32 (LBA)
# 532480 Linux

# Reads the sector size from the output of an `fdisk` command like the following:
#   fdisk -l [...] <disk_image.img>
#
# Takes a single paramter, which is a string containing the output of the fdisk command.
#
# This was developed and tested using fdisk from 'util-linux 2.34'
function get_sector_size ()
{
  local fdisk_output="$1"
  if [ -z "${fdisk_output}" ]; then
    die "You must supply an argument containing the fdisk output."
  fi
  
  local sector_size=$( \
    echo -n "${fdisk_output}" | \
      egrep --only-matching --line-regexp "Units: sectors of [0-9]+ \* [0-9]+ = [0-9]+ bytes" | \
      sed -e 's/.*= \([0-9]\+\) bytes/\1/g' )

  if [ ! -z "${sector_size}" ]; then
    echo "${sector_size}"
  else
    die "Unable to read sector size from 'fdisk' result."
  fi
}

# Reads the starting sector for size from the output of an `fdisk` command like the following:
#   fdisk -l -o start[,...] [...] <disk_image.img>
#
# Takes two parameters:
#   - a string containing the output of the fdisk command
#   - the partition number to query, starting with '1'
#
# This was developed and tested using fdisk from 'util-linux 2.34'
function get_partition_start ()
{
  local fdisk_output="$1"
  local partition_number="$2"
  local partition_line_number=$((partition_number + 8))

  if [ -z "${fdisk_output}" ]; then
    die "You must supply an argument containing the fdisk output."
  fi
  if [ -z "${partition_number}" ] || [ ! "${partition_number}" -gt 0 ]; then
    die "You must supply a partition number greater than 0."
  fi

  local start=$( \
    echo -n "${fdisk_output}" | \
      sed -n "${partition_line_number} p" | \
      awk '{print $1}' )

  if [ ! -z "${start}" ]; then
    echo "${start}"
  else
    die "Unable to read start sector for partition ${partition_number} from 'fdisk' result."
  fi
}

# Gets the offset (suitable for use in `mount`) for a specific partition within a multi-partition
# image
function get_partition_offset ()
{
  local disk_image_file="$1"
  local partition_number="$2"

  if [ -z "${disk_image_file}" ]; then
    die "You must supply an argument containing the disk image filename."
  fi
  if [ ! -f "${disk_image_file}" ]; then
    die "Disk image file does not exist: ${disk_image_file}"
  fi
  if [ -z "${partition_number}" ] || [ ! "${partition_number}" -gt 0 ]; then
    die "You must supply a partition number greater than 0."
  fi

  local fdisk_output=$(fdisk -l -o start,device,type "${disk_image_file}")
  local sector_size=$(get_sector_size "${fdisk_output}")
  local partition_start=$(get_partition_start "${fdisk_output}" "${partition_number}")

  echo $((sector_size * partition_start))
}

